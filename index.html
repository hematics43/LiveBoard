<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>üî¥ BlackBoard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: #222;
      color: white;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    #header {
      background: #111;
      color: #fff;
      text-align: center;
      font-size: 20px;
      font-weight: bold;
      padding: 10px;
      border-bottom: 2px solid #444;
      flex-shrink: 0;
    }

    #topToolbar, #bottomToolbar {
      background: rgba(0, 0, 0, 0.9);
      padding: 6px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      flex-shrink: 0;
    }

    #canvasContainer {
      flex-grow: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #000;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #fff;
      touch-action: none;
    }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    #clearBtn { background: red; color: #fff; }
    #eraserBtn { background: gray; color: #fff; }
    #downloadBtn { background: green; color: #fff; }
    #deleteImgBtn { background: darkorange; color: #fff; }
    #undoBtn { background: dodgerblue; color: #fff; }
    #redoBtn { background: teal; color: #fff; }

    #fullscreenBtn {
      position: fixed;
      bottom: 60px;
      right: 15px;
      background: #000;
      color: #fff;
      font-size: 20px;
      border-radius: 50%;
      width: 45px;
      height: 45px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 30;
      border: 2px solid #444;
    }
    #fullscreenBtn:hover { background: #333; }

    /* Fullscreen flex layout */
    body {
      display: flex;
      flex-direction: column;
    }
  </style>
</head>
<body>
  <!-- Heading -->
  <div id="header">üî¥ BlackBoard</div>

  <!-- Top Toolbar -->
  <div id="topToolbar">
    <label>‚úèÔ∏è Color: <input type="color" id="colorPicker" value="#000000"></label>
    <label>üìè Size: <input type="range" id="sizePicker" min="1" max="30" value="3"></label>
    <button id="undoBtn">‚Ü©Ô∏è Undo</button>
    <button id="redoBtn">‚Ü™Ô∏è Redo</button>
    <label>üé® Background: <input type="color" id="bgColorPicker" value="#ffffff"></label>
  </div>

  <!-- Canvas container -->
  <div id="canvasContainer">
    <canvas id="board"></canvas>
  </div>

  <!-- Bottom Toolbar -->
  <div id="bottomToolbar">
    <input type="file" id="uploadImage" accept="image/*">
    <button id="deleteImgBtn">‚ùå Delete Image</button>
    <button id="eraserBtn">ü©π Eraser</button>
    <button id="clearBtn">üßπ Clear</button>
    <button id="downloadBtn">üíæ Download</button>
  </div>

  <!-- Fullscreen Button -->
  <div id="fullscreenBtn">‚õ∂</div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
    // ‚úÖ Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyCIDLsM2YKD2Uw5C_v-n97P5wz4eSUfO_M",
      authDomain: "liveboard-fb357.firebaseapp.com",
      databaseURL: "https://liveboard-fb357-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "liveboard-fb357",
      storageBucket: "liveboard-fb357.firebasestorage.app",
      messagingSenderId: "85829681917",
      appId: "1:85829681917:web:3e82b038cba88db0e5b494"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");

    const colorPicker = document.getElementById("colorPicker");
    const sizePicker = document.getElementById("sizePicker");
    const bgColorPicker = document.getElementById("bgColorPicker");
    const uploadImage = document.getElementById("uploadImage");
    const deleteImgBtn = document.getElementById("deleteImgBtn");
    const clearBtn = document.getElementById("clearBtn");
    const eraserBtn = document.getElementById("eraserBtn");
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
    const downloadBtn = document.getElementById("downloadBtn");
    const fullscreenBtn = document.getElementById("fullscreenBtn");

    let drawing = false, lastX = 0, lastY = 0;
    let brushColor = colorPicker.value, brushSize = sizePicker.value;
    let erasing = false, currentBgColor = "#ffffff";
    let linesCache = [], bgImage = null;
    let undoStack = [], redoStack = [];

    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      redrawAll();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function drawLine(x1, y1, x2, y2, color, size) {
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function redrawAll() {
      ctx.fillStyle = currentBgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (bgImage) {
        let imgRatio = bgImage.width / bgImage.height;
        let canvasRatio = canvas.width / canvas.height;
        let drawWidth, drawHeight, offsetX, offsetY;

        if (imgRatio > canvasRatio) {
          drawWidth = canvas.width;
          drawHeight = canvas.width / imgRatio;
          offsetX = 0;
          offsetY = (canvas.height - drawHeight) / 2;
        } else {
          drawHeight = canvas.height;
          drawWidth = canvas.height * imgRatio;
          offsetX = (canvas.width - drawWidth) / 2;
          offsetY = 0;
        }
        ctx.drawImage(bgImage, offsetX, offsetY, drawWidth, drawHeight);
      }

      linesCache.forEach(line =>
        drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size)
      );
    }

    function drawAndSave(x, y) {
      const color = erasing ? currentBgColor : brushColor;
      const line = { x1: lastX, y1: lastY, x2: x, y2: y, color, size: brushSize };
      drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
      const newRef = db.ref("blackboard/lines").push(line);
      undoStack.push({ key: newRef.key, line });
      redoStack = [];
      [lastX, lastY] = [x, y];
    }

    // Mouse
    canvas.addEventListener("mousedown", e => {
      drawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];
    });
    canvas.addEventListener("mousemove", e => {
      if (!drawing) return; drawAndSave(e.offsetX, e.offsetY);
    });
    canvas.addEventListener("mouseup", () => drawing = false);
    canvas.addEventListener("mouseleave", () => drawing = false);

    // Touch
    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      drawing = true; [lastX, lastY] = [t.clientX - rect.left, t.clientY - rect.top];
    });
    canvas.addEventListener("touchmove", e => {
      e.preventDefault();
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      drawAndSave(t.clientX - rect.left, t.clientY - rect.top);
    });
    canvas.addEventListener("touchend", () => drawing = false);

    // Firebase sync
    db.ref("blackboard/lines").on("child_added", snap => {
      const line = snap.val(); line._key = snap.key;
      linesCache.push(line); drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
    });
    db.ref("blackboard/lines").on("child_removed", snap => {
      linesCache = linesCache.filter(l => l._key !== snap.key);
      redrawAll();
    });

    // Tools
    colorPicker.oninput = () => { brushColor = colorPicker.value; erasing = false; };
    sizePicker.oninput = () => { brushSize = sizePicker.value; };
    eraserBtn.onclick = () => {
      erasing = !erasing;
      eraserBtn.style.background = erasing ? "orange" : "gray";
    };
    bgColorPicker.oninput = () => {
      currentBgColor = bgColorPicker.value;
      db.ref("background").set(currentBgColor);
      redrawAll();
    };
    db.ref("background").on("value", snap => {
      if (snap.exists()) { currentBgColor = snap.val(); bgColorPicker.value = currentBgColor; redrawAll(); }
    });

    clearBtn.onclick = () => {
      db.ref("blackboard").remove();
      db.ref("background").set(currentBgColor);
      db.ref("image").remove();
      undoStack = []; redoStack = [];
    };

    uploadImage.onchange = e => {
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => db.ref("image").set(ev.target.result);
      reader.readAsDataURL(file);
    };
    db.ref("image").on("value", snap => {
      if (snap.exists()) {
        const img = new Image();
        img.onload = () => { bgImage = img; redrawAll(); };
        img.src = snap.val();
      } else { bgImage = null; redrawAll(); }
    });
    deleteImgBtn.onclick = () => db.ref("image").remove();

    undoBtn.onclick = () => {
      if (undoStack.length > 0) {
        const last = undoStack.pop();
        redoStack.push(last);
        db.ref("blackboard/lines/" + last.key).remove();
      }
    };
    redoBtn.onclick = () => {
      if (redoStack.length > 0) {
        const item = redoStack.pop();
        db.ref("blackboard/lines/" + item.key).set(item.line);
        undoStack.push(item);
      }
    };

    downloadBtn.onclick = () => {
      const link = document.createElement("a");
      link.download = "blackboard.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    };

    fullscreenBtn.onclick = () => {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen();
      else document.exitFullscreen();
    };
  </script>
</body>
</html>
