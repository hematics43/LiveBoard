<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>🔴 BlackBoard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: #222;
      color: white;
      font-family: Arial, sans-serif;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #header {
      background: #111;
      color: #fff;
      text-align: center;
      font-size: 20px;
      font-weight: bold;
      padding: 10px;
      border-bottom: 2px solid #444;
      flex-shrink: 0;
    }

    #topToolbar, #bottomToolbar {
      background: rgba(0, 0, 0, 0.9);
      padding: 6px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      flex-shrink: 0;
    }

    #canvasContainer {
      flex-grow: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #000;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #fff;
      touch-action: none;
    }

    button, select {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    #clearBtn { background: red; color: #fff; }
    #eraserBtn { background: gray; color: #fff; }
    #downloadBtn { background: green; color: #fff; }
    #deleteImgBtn { background: darkorange; color: #fff; }

    #fullscreenBtn {
      position: fixed;
      bottom: 60px;
      right: 15px;
      background: #000;
      color: #fff;
      font-size: 20px;
      border-radius: 50%;
      width: 45px;
      height: 45px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 30;
      border: 2px solid #444;
    }
    #fullscreenBtn:hover { background: #333; }
  </style>
</head>
<body>
  <!-- Heading -->
  <div id="header">🔴 BlackBoard</div>

  <!-- Top Toolbar -->
  <div id="topToolbar">
    <label>✏️ Color: <input type="color" id="colorPicker" value="#000000"></label>
    <label>📏 Size: <input type="range" id="sizePicker" min="1" max="30" value="3"></label>
    <label>🎨 Background: <input type="color" id="bgColorPicker" value="#ffffff"></label>
    <label>😊 Emoji: 
      <select id="emojiPicker">
        <option value="">--Select--</option>
        <option>😀</option>
        <option>😂</option>
        <option>😍</option>
        <option>👍</option>
        <option>🔥</option>
        <option>🌟</option>
        <option>💡</option>
        <option>🎉</option>
        <option>🚀</option>
        <option>❤️</option>
      </select>
    </label>
  </div>

  <!-- Canvas container -->
  <div id="canvasContainer">
    <canvas id="board"></canvas>
  </div>

  <!-- Bottom Toolbar -->
  <div id="bottomToolbar">
    <input type="file" id="uploadImage" accept="image/*">
    <button id="deleteImgBtn">❌ Delete Image</button>
    <button id="eraserBtn">🩹 Eraser</button>
    <button id="clearBtn">🧹 Clear</button>
    <button id="downloadBtn">💾 Download</button>
  </div>

  <!-- Fullscreen Button -->
  <div id="fullscreenBtn">⛶</div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
    // ✅ Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyCIDLsM2YKD2Uw5C_v-n97P5wz4eSUfO_M",
      authDomain: "liveboard-fb357.firebaseapp.com",
      databaseURL: "https://liveboard-fb357-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "liveboard-fb357",
      storageBucket: "liveboard-fb357.firebasestorage.app",
      messagingSenderId: "85829681917",
      appId: "1:85829681917:web:3e82b038cba88db0e5b494"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");

    const colorPicker = document.getElementById("colorPicker");
    const sizePicker = document.getElementById("sizePicker");
    const bgColorPicker = document.getElementById("bgColorPicker");
    const uploadImage = document.getElementById("uploadImage");
    const deleteImgBtn = document.getElementById("deleteImgBtn");
    const clearBtn = document.getElementById("clearBtn");
    const eraserBtn = document.getElementById("eraserBtn");
    const downloadBtn = document.getElementById("downloadBtn");
    const fullscreenBtn = document.getElementById("fullscreenBtn");
    const emojiPicker = document.getElementById("emojiPicker");

    let drawing = false, lastX = 0, lastY = 0;
    let brushColor = colorPicker.value, brushSize = sizePicker.value;
    let erasing = false, currentBgColor = "#ffffff";
    let linesCache = [], emojiCache = [], bgImage = null;
    let selectedEmoji = "";

    // For dragging emojis
    let draggingEmoji = null;

    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      redrawAll();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function drawLine(x1, y1, x2, y2, color, size) {
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function drawEmoji(x, y, emoji, size=brushSize) {
      ctx.font = `${size * 10}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(emoji, x, y);
    }

    function redrawAll() {
      ctx.fillStyle = currentBgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (bgImage) {
        let imgRatio = bgImage.width / bgImage.height;
        let canvasRatio = canvas.width / canvas.height;
        let drawWidth, drawHeight, offsetX, offsetY;

        if (imgRatio > canvasRatio) {
          drawWidth = canvas.width;
          drawHeight = canvas.width / imgRatio;
          offsetX = 0;
          offsetY = (canvas.height - drawHeight) / 2;
        } else {
          drawHeight = canvas.height;
          drawWidth = canvas.height * imgRatio;
          offsetX = (canvas.width - drawWidth) / 2;
          offsetY = 0;
        }
        ctx.drawImage(bgImage, offsetX, offsetY, drawWidth, drawHeight);
      }

      linesCache.forEach(line =>
        drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size)
      );

      emojiCache.forEach(item =>
        drawEmoji(item.x, item.y, item.emoji, item.size)
      );
    }

    function drawAndSave(x, y) {
      if (selectedEmoji) {
        const emojiItem = { x, y, emoji: selectedEmoji, size: brushSize };
        const ref = db.ref("blackboard/emojis").push();
        emojiItem._key = ref.key;
        ref.set(emojiItem);
      } else {
        const color = erasing ? currentBgColor : brushColor;
        const line = { x1: lastX, y1: lastY, x2: x, y2: y, color, size: brushSize };
        drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
        db.ref("blackboard/lines").push(line);
      }
      [lastX, lastY] = [x, y];
    }

    function findEmojiAt(x, y) {
      return emojiCache.find(item => {
        const size = item.size * 10;
        return (x > item.x - size/2 && x < item.x + size/2 &&
                y > item.y - size/2 && y < item.y + size/2);
      });
    }

    function startDrawingOrDrag(x, y) {
      if (selectedEmoji) {
        drawAndSave(x, y);
        selectedEmoji = "";
        emojiPicker.value = "";
      } else {
        const emoji = findEmojiAt(x, y);
        if (emoji) {
          draggingEmoji = emoji;
        } else {
          drawing = true; [lastX, lastY] = [x, y];
        }
      }
    }

    function moveDrawingOrDrag(x, y) {
      if (draggingEmoji) {
        draggingEmoji.x = x; draggingEmoji.y = y;
        db.ref("blackboard/emojis/" + draggingEmoji._key).set(draggingEmoji);
      } else if (drawing) {
        drawAndSave(x, y);
      }
    }

    function stopDrawingOrDrag() {
      drawing = false;
      draggingEmoji = null;
    }

    // Mouse
    canvas.addEventListener("mousedown", e => startDrawingOrDrag(e.offsetX, e.offsetY));
    canvas.addEventListener("mousemove", e => moveDrawingOrDrag(e.offsetX, e.offsetY));
    canvas.addEventListener("mouseup", stopDrawingOrDrag);
    canvas.addEventListener("mouseleave", stopDrawingOrDrag);

    // Touch
    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      startDrawingOrDrag(t.clientX - rect.left, t.clientY - rect.top);
    });
    canvas.addEventListener("touchmove", e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      moveDrawingOrDrag(t.clientX - rect.left, t.clientY - rect.top);
    });
    canvas.addEventListener("touchend", stopDrawingOrDrag);

    // Firebase sync
    db.ref("blackboard/lines").on("child_added", snap => {
      const line = snap.val();
      linesCache.push(line);
      drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
    });

    db.ref("blackboard/emojis").on("child_added", snap => {
      const item = snap.val(); item._key = snap.key;
      emojiCache.push(item);
      drawEmoji(item.x, item.y, item.emoji, item.size);
    });
    db.ref("blackboard/emojis").on("child_changed", snap => {
      const updated = snap.val(); updated._key = snap.key;
      emojiCache = emojiCache.map(e => e._key === snap.key ? updated : e);
      redrawAll();
    });
    db.ref("blackboard").on("child_removed", () => {
      linesCache = [];
      emojiCache = [];
      redrawAll();
    });

    // Tools
    colorPicker.oninput = () => { brushColor = colorPicker.value; erasing = false; selectedEmoji = ""; };
    sizePicker.oninput = () => { brushSize = sizePicker.value; };
    eraserBtn.onclick = () => {
      erasing = !erasing; selectedEmoji = "";
      eraserBtn.style.background = erasing ? "orange" : "gray";
    };
    bgColorPicker.oninput = () => {
      currentBgColor = bgColorPicker.value;
      db.ref("background").set(currentBgColor);
      redrawAll();
    };
    db.ref("background").on("value", snap => {
      if (snap.exists()) { currentBgColor = snap.val(); bgColorPicker.value = currentBgColor; redrawAll(); }
    });

    clearBtn.onclick = () => {
      db.ref("blackboard").remove();
      db.ref("background").set(currentBgColor);
      db.ref("image").remove();
    };

    uploadImage.onchange = e => {
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => db.ref("image").set(ev.target.result);
      reader.readAsDataURL(file);
    };
    db.ref("image").on("value", snap => {
      if (snap.exists()) {
        const img = new Image();
        img.onload = () => { bgImage = img; redrawAll(); };
        img.src = snap.val();
      } else { bgImage = null; redrawAll(); }
    });
    deleteImgBtn.onclick = () => db.ref("image").remove();

    downloadBtn.onclick = () => {
      const link = document.createElement("a");
      link.download = "blackboard.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    };

    fullscreenBtn.onclick = () => {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen();
      else document.exitFullscreen();
    };

    emojiPicker.onchange = () => {
      selectedEmoji = emojiPicker.value;
      erasing = false;
    };
  </script>
</body>
</html>
